import React, { Component } from "react";
import "../../static/auth/view.css";
import Services, { stdPaingationSize } from "../../utils/utils";
import * as signalR from "@microsoft/signalr";
import { FaChevronUp, FaRegComment, FaShare } from "react-icons/fa";
import { FaChevronDown } from "react-icons/fa6";
import SideNavPost from "./useable/SideNavPost";
import { AiOutlinePlusCircle } from "react-icons/ai";
import Face6Icon from '@mui/icons-material/Face6';
import EmojiPeopleIcon from '@mui/icons-material/EmojiPeople';
import ReportGmailerrorredIcon from '@mui/icons-material/ReportGmailerrorred';
import Pagination from '@mui/material/Pagination';
import { AdminContext } from "../../Admin/Admin";
import AuthContext from "../../auth/auth";

// this is the reuseable recursive method for setting up in the hierarchial data tree,
// I think some languages that I have used in the past comes with built in method like this
// I had to deal with Response object and http header but this will do that job in our case.

// as a developer, if your recursion failed in client side, at wrost,
// all it can do is crash client's browser, but if it failed in server,it will break everything
export const setParentCommentValue = (rootNode, parentNode, value) => { // we have a problem here
  if (!rootNode) return; // Added safety check

  const parentId = parentNode.id; // we need to find this "id" there and set it
  // search for parent
  const parent = rootNode.find((u) => u.id === parentId);

  if (parent === undefined) {
    // in not found case
    // we need to search its child, since it can multiple child we need to loop over;
    for (let i in rootNode) {
      const currentNode = rootNode[i];
      const { replies } = currentNode;

      // Added check to ensure replies exists before recursion
      if (replies && Array.isArray(replies)) {
        setParentCommentValue(replies, parentNode, value);
      }
    }
  } else {
    // Ensure parent.replies exists
    if (!parent.replies) parent.replies = [];
    
    const { replies } = parent;
    // here check for dublicates
    if (!(Array.isArray(value))) {
      const checkInParent = replies.find((x) => x.id === value.id);
      if (checkInParent === undefined) {
        parent.replies.push(value);
      }
      return parent;
    } else {
      // if it's an array then we need to do things in different way
      // why don't iterate over value and append it? think about run time complexity
      for (let currValue in value) {
        const currentValue = value[currValue];
        const checkInParent = replies.find((x) => x.id === currentValue.id);
        if (checkInParent === undefined) { // we could make this better I will leave it as it is for now
          parent.replies.push(currentValue);
        }
      }
      return parent;
    }
  }
};

class Comment extends Component {
  constructor(props) {
    super(props);
    this.addComment = this.addComment.bind(this);
  }

  services = new Services();
  url = new URLSearchParams(window.location.search);

  state = {
    page: 1,
    confessions: [],
    confessionsCopy: [],
    totalPages: 1,
  };

  /* Here we do need to create a method that can expand, the comments that are like the 
  leaf node. In order to do that we must first go step by step in fetching those nodes.
  We do not want to make a special case for any of those, we want to keep the logic same. */
  // I mean that could be done but I don't want to complexity will be way high

  getConfession = (page) => {
    fetch(
      `Confession/GetComments?confessionId=${this.url.get("topic")}&page=${page}`,
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.services.accessToken()}`,
        },
        method: "get",
      }
    )
      .then((r) => r.json())
      .then((response) => {
        const { statusCode, value } = response;
        if (statusCode === 200) {
          const { data, totalObjects, totalPages } = value;

          this.setState({
            confession: []
          }, () => {
            /* Even a simple problem here,
            will require me a whiteboard and cup of coffee. */

            this.setState({
              confessions: data,
              totalObjects,
              totalPages,
            }, () => {

            });
          });
        }
      });
  }



  // again using like arrow function automatically binds it
  componentDidMount = () => {
    const connection = new signalR.HubConnectionBuilder()
      .withUrl("/chatHub")
      .withAutomaticReconnect()
      .build();

    /* We have a problen, when the data comes from the socket,
    and if we click on "thread" it renders thread of parent which is
    not related to the parent thread */
    connection.on(
      "ReceiveMessage",
      function (valueFromSocket) {
        /* Here we receive message from web socket, and data should be sync because,
        we made it depend upon this compoenent after complex recursive compoenent binding */
        
        // FIX: Removed 'const { confessions } = this.state;' to avoid closure staleness
        const { value, parent, order } = valueFromSocket;

        // we need to hande the case where this is not a reply

        // confession parent value
        /* Here is a bug it's because how we assign "reply" to the parent by simply
        equaling we need to comple the array, so passing values as iterable,
        the bug might lie in the way we are assigning the [value] */
        if (order === "thread") {
          // FIX: Use functional setState and Deep Clone to prevent direct mutation
          this.setState(prevState => {
             const confessionsCopy = JSON.parse(JSON.stringify(prevState.confessions));
             /*
             Previously there was a bug that happened sometimes when sending a message,
             even though the recur-funciton worked it never updated the array in state, and
             message never got rendered. I found out that we needed to create an copy of the array.
             
             */
             setParentCommentValue(confessionsCopy, parent, value);
             return { confessions: confessionsCopy };
          });
        } else if (order === "top-level") { // Removed check '&& confessions.length <= stdPaingationSize' to ensure real-time update
          // then we need to directly add into that confession array;

          // we have a problem here, the recursive function wont structure the data correctly

          /* We have a problem here, sometimes when I reply to a thread then the data
          does not get's rendered. */
          this.setState(prevState => ({
            confessions: [
              parent,
              ...prevState.confessions,
            ]
          }));
        }
      }.bind(this)
    );

    connection
      .start()
      .then(() => {
        return connection.invoke("JoinChat", this.url.get("topic").toString());
      })
      .catch((err) => console.error("Connection failed: ", err));

    this.getConfession(this.state.page);
  }

  addComment(ev) {
    ev.preventDefault();
    const formData = new FormData(ev.target);
    const comment = formData.get("comment");
    fetch(
      `Confession/AddComment?comments=${comment}&confessionId=${this.url.get(
        "topic"
      )}`,
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.services.accessToken()}`,
        },
        method: "post",
      }
    )
      .then((r) => r.json())
      .then((response) => {
        const { statusCode } = response;
        if (statusCode === 200) {
          ev.target.reset();
          // now what we want to do is re fetch the comments again, in initial page
          
          // FIX: Commented out to prevent race condition. Socket "ReceiveMessage" will handle the update.
          // this.getConfession(1);
          // this.setState({ page: 1 });
          return;
        }
      });
  }

  /* Another issue, is when simply replying to a thread, what are facing is
  only the reply being rendered we need to fix that by fetching everything. */

  /* What we need to do is okay, we need to render the chuldren comment associated with everything we may hide it
    using css and later we can expand it.  */

  dataOnRoot = (parent) => {
    // here we might have binding issues, I came to know that arrow function automatically binds stuff
    const services = new Services();
    fetch(`Confession/get-children-comments?parentId=${parent.id}`, {
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${services.accessToken()}`,
      },
      method: "get",
    })
      .then((r) => r.json())
      .then((response) => {
        const { value, statusCode } = response;
        if (value.length === 0) return;
        
        // FIX: Removed 'const { confessions } = this.state;'
        if (statusCode === 200) {
          
          // FIX: Use functional setState and Deep Clone.
          this.setState(prevState => {
             const confessionsCopy = JSON.parse(JSON.stringify(prevState.confessions));
             setParentCommentValue(confessionsCopy, parent, value); // there is nth wrong with this function
             return { confessions: confessionsCopy };
          });
          
          /* Bug: when trying to expand this thread after navigation around in some pages,
          then we will have problem, even though it stays in confession variable, but the state does not want to trigger.

          Whatever I try it's not triggiring the change in state! here so I neeed to figure out a way!
          */
          
          // The hack below is no longer needed because we are creating a new object reference above
          /*
          this.setState({
            confessions: []
          }, () => {
            this.setState({ confessions });
          });
          */
          return;
        }
      });
  };

  handleChange = (ev, val) => {
    /* Here we have a probme, when we expand any of the thread,
    and navigate around the pages we keep on seeing that expanded threead no matter what we do.

    Let's understand how this thread expansion works, first of all thread is expanded when we have a change in parent state,
    There is no state triggring to like render that particular compoenent. It renders children when we click that expand button.

    But my question is why couldn't the state get triggered when the state was re-setted to empty array and back to original value?
    */

    this.getConfession(val);
    this.setState({ page: val });
  }

  render() {
    /* If we want to expand the reply box table we need to change the Higher Order Object
        that we get from fetch API call so that we can re-render everything */
    return (
      <AdminContext.Consumer>
        {(adminProperties) => {
          const { dark } = adminProperties;

          // Modernized Pagination styles
          const darkPagination = {
            '& .MuiPaginationItem-root': {
              color: '#9ca3af', // Muted text
              borderColor: 'rgba(255, 255, 255, 0.1)',
              transition: 'all 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
              fontFamily: 'inherit',
              fontWeight: 600,
              '&:hover': {
                backgroundColor: 'rgba(255, 255, 255, 0.05)',
                color: '#fff',
                transform: 'translateY(-2px)', // Modern "lift" effect
              },
              '&.Mui-selected': {
                background: 'linear-gradient(135deg, #6366f1 0%, #a855f7 100%)', // Matches your avatar
                color: '#fff',
                boxShadow: '0 4px 12px rgba(99, 102, 241, 0.3)',
                '&:hover': {
                  background: 'linear-gradient(135deg, #4f46e5 0%, #9333ea 100%)',
                },
              },
            },
            '& .MuiPaginationItem-ellipsis': {
              color: '#4b5563',
            },
          };

          return (
            <div className={`forum-container ${dark ? 'theme-dark' : 'theme-light'}`}>
              <div className="section-divider">
                <span>Discussion</span>
              </div>

              <form onSubmit={this.addComment} className="modern-comment-form">
                <div className={`comment-composer ${dark ? 'dark-mode' : 'light-mode'}`}>
                  <textarea
                    name="comment"
                    className="creative-textarea"
                    placeholder="Share your perspective..."
                    autoComplete="off"
                    disabled={this.props.deletedConfession === true}
                  />
                  <div className="composer-footer">
                    <div className="guideline-text">Please be respectful</div>
                    <button type="submit" className="glow-submit-button">
                      Post Comment
                    </button>
                  </div>
                </div>
              </form>
              <hr style={{ visibility: "hidden" }}></hr>

              <div id="chat-fourm-frame" className="comment-feed">
                {this.state.confessions && this.state.confessions.map((i) => {
                  const { replyCount } = i;
                  return (
                    <div key={i.id} className="comment-thread-group">
                      <CommentRenderCompoenent obj={i} />

                      {replyCount > 0 && (
                        <button
                          className="thread-load-btn"
                          onClick={() => this.dataOnRoot(i)}
                        >
                          <AiOutlinePlusCircle className="btn-icon" />
                          <span>View {replyCount} {replyCount === 1 ? 'reply' : 'replies'}</span>
                        </button>
                      )}

                      <div className="recursive-indent">
                        <CommentRecurComponent
                          load={this.dataOnRoot}
                          children={i.replies}
                        />
                      </div>
                    </div>
                  );
                })}
              </div>

              <div className="pagination-wrapper">
                <Pagination
                  count={this.state.totalPages}
                  page={this.state.page}
                  variant="outlined"
                  shape="circular" // Circular is more "modern" than rounded
                  onChange={this.handleChange}
                  sx={dark ? darkPagination : {
                    '& .MuiPaginationItem-root': {
                      fontWeight: 600,
                      transition: 'all 0.2s'
                    }
                  }}
                />
              </div>
            </div>
          );
        }}
      </AdminContext.Consumer>
    );
  }
}

class CommentRenderCompoenent extends Component {
  constructor(props) {
    super(props);
    this.replyCommentUpload = this.replyCommentUpload.bind(this);
  }
  url = new URLSearchParams(window.location.search);
  state = {
    showReplyThread: false,
  };
  services = new Services();
  replyCommentUpload(ev, parentId) {
    ev.preventDefault();
    const data = new FormData(ev.target);
    const comment = data.get("comment");

    fetch(
      `Confession/ReplyComment?comment=${comment}&confessionId=${this.url.get(
        "topic"
      )}&parentId=${parentId}`,
      {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${this.services.accessToken()}`,
        },
        method: "post",
      }
    )
      .then((r) => r.json())
      .then((response) => {
        const { statusCode } = response;
        if (statusCode === 200) {
          ev.target.reset();
          this.setState({ showReplyThread: false });
          return;
        }
        if (statusCode === 400) {
          const { value } = response;
          const { message } = value;
          alert(message);
        }
      }).catch((err) => {
        alert(err);
      });
  }

  render() {
    const i = this.props.obj;
    return (
      <AuthContext.Consumer>
        {(adminProperties) => {
          const { dark } = adminProperties;
          return (
            <>
              <React.Fragment>
                <div className={`comment-card ${i.deleted ? 'is-deleted' : ''}`}>

                  {/* --- Report Modal Overlay --- */}
                  {this.state.report && (
                    <div className="report-overlay">
                      <ReportConfessionAndComment
                        reportFor={{ type: "comments", id: i.id }}
                        closeDiag={() => this.setState({ report: false })}
                      />
                    </div>
                  )}

                  {/* --- Header: Identity & Timestamp --- */}
                  <div className="comment-header">
                    <div className="identity-group">
                      <div
                        className="user-avatar-glow"
                        style={{ '--accent-color': i.profileColor }}
                      >
                        <EmojiPeopleIcon className="avatar-icon" />
                      </div>
                      <div className="user-meta">
                        <div className="user-name-row">
                          <span className="user-label">Unsigned Responder</span>
                          <span className="user-hash">#{i.anonymousName.substring(0, 5)}</span>
                        </div>
                        <span className="timestamp">
                          {this.services.normalizeASPDate(i.added)}
                        </span>
                      </div>
                    </div>
                  </div>

                  <div className="comment-body">
                    {i.comments}
                  </div>

                  <div className="interaction-bar">
                    <div className="action-pill voting-pill">
                      <button className="vote-btn up btn" aria-label="Upvote">
                        <FaChevronUp />
                      </button>
                      <span className="vote-count">0</span>
                      <button className="vote-btn down btn" aria-label="Downvote">
                        <FaChevronDown />
                      </button>
                    </div>

                    <button
                      className={`action-pill ${this.state.showReplyThread ? 'active' : ''}`}
                      onClick={() => {
                        if (!i.deleted) {
                          this.setState(prev => ({ showReplyThread: !prev.showReplyThread }));
                        }
                      }}
                    >
                      <FaRegComment />
                      <span>Reply</span>
                    </button>

                    <button className="action-pill">
                      <FaShare />
                      <span>Share</span>
                    </button>

                    <button
                      className="action-pill report-btn"
                      onClick={() => {
                        if (i.deleted) return alert("You cannot report a deleted message!");
                        this.setState({ report: true });
                      }}
                    >
                      <ReportGmailerrorredIcon />
                    </button>
                  </div>

                  {/* --- Nested Reply Form --- */}
                  {this.state.showReplyThread && (
                    <div>
                      <form
                        className={`comment-composer ${dark ? 'dark-mode' : 'light-mode'}`}
                        onSubmit={(ev) => this.replyCommentUpload(ev, i.id)}
                      >
                        <textarea
                          placeholder="Write a thoughtful reply..."
                          autoComplete="off"
                          name="comment"
                          className={`creative-textarea thread-textarea-color-dark`}
                          autoFocus
                        />
                        <div className="reply-actions">
                          <button
                            type="button"
                            className={`text-btn btn btn-light`}
                            onClick={() => this.setState({ showReplyThread: false })}
                          >
                            Cancel
                          </button>
                          <button type="submit" className="send-btn btn">
                            Post Reply
                          </button>
                        </div>
                      </form>
                    </div>
                  )}
                </div>
              </React.Fragment>
            </>
          )
        }}
      </AuthContext.Consumer>
    );
  }
}

/* It's not "Web Dev" that people think it is, it's a complicated stuff here, 
You are managing a web socket's, making things re useable, you need to check the data structure
and make sure it works both from web socket and logcal data, rendering happens smoothly, it's problem solving,
make it clear and consise in future if you were to debug it you will have problem yourself. 
And, who cares c# is in the backend with a database */

class CommentRecurComponent extends Component {
  // this is recursive component, which is used to render comment and add comment options, this might be little confusing to make
  // because our mind might go to recursive hell.
  constructor(props) {
    super(props);
    this.changeDemand.bind(this);
  }

  // Loading data on demand because, in a complex chat system there are lot's of user driven data, that might load our server,
  // like images and videos.

  state = {
    children: [],
  };

  services = new Services();

  // this get's called in one instance of class, we need to make this rely on single node
  // every time we pass that particular node, the compoenent should update
  // since it's a recursive compoenent
  componentDidMount() {
    // simple it's get loaded for first order "node"
    if (this.props.children !== undefined) {
      const { children } = this.props;
      this.setState(
        {
          children,
        },
        () => { }
      );
    }
  }

  componentDidUpdate(prevProps, prevState) {
    // Fixed: Added check to update children when props change (vital for recursion updates)
    if (prevProps.children !== this.props.children) {
      this.setState({ children: this.props.children });
    }
    
    if (prevState.nextedReply !== this.state.nextedReply) {

    }
  }

  /* Here lies to mind blowing complixity of application,
      Recursion happens in two phases, first time this "compoenet" is called from parent compoenent,
      Second and "n" times this compoenent is called from this compoenent itself,
      Since we want to make data sync from web-sockets and fetch call. We want this all thing to render once the "root" node is changed, using "DSA"terminilogy

      For the first phase we could ping this, and invoke the method in parent componenet,
      For the second phase parent itself is the current child compoenent that's how recursion works in computer.

      Question is how do we bind in sucha way that things work out?
  */
  changeDemand = (obj) => {
    this.props.load(obj);
  };

  /* Here we need to make things to work such that everything depnds dupon the parent,
    compoenent, so that we can make the data sync between the data incomming from the websocket
    and the data that comes locally, and data that comes through fetch api, 
    In order to make something like that what we need to do is make this compoenent, 
    send the fetched data to parent compoenet and this data compoenent get's called again. */

  render() {
    /* Here what this code does it, it checks if we have reply which is greater than 0
        if not then we can click to make a fetch api call to render more,
        what are the props passed to this compoenent, it's the parent compoenent okay
        if we have children then we render children. If not then we can ask to make a fetch call,


        root comment = {
        children_comment: [{
            children_Comment: [{
            }]
        }]; /// this is same data that comes from fetch() call websocket() and local data()
        
    }
        */

    const { children } = this.state;
    const { load } = this.props; // OH WOW, DESTRUCTURING HERE WORKS, NOT IN THE PARAMTER OF THE COMPOENENT THERE IS A DIFFERENCE

    /* Okay Good we have a problem here I shouldn't be thinking this is hard, even though 
    for someone new it is, I will find it */
    return (
      <>
        <div className="recur-comment-frame">
          {children && children.length > 0
            ? children.map((i, j) => {
              const { replies, replyCount } = i;
              return (
                <React.Fragment key={j}>
                  <CommentRenderCompoenent obj={i} />
                  <>
                    {(replyCount === 0 || replyCount === undefined) ? null : (
                      <>
                        <button
                          className="thread-load-btn"
                          onClick={() => this.changeDemand(i)}
                        >
                          <AiOutlinePlusCircle className="btn-icon" />
                          <span>View {replyCount} {replyCount === 1 ? 'reply' : 'replies'}</span>
                        </button>
                        <hr style={{ visibility: "hidden" }} />
                      </>
                    )}
                    {replies && replies.length > 0 && (
                      <>

                        <CommentRecurComponent
                          children={i.replies}
                          load={load}
                        />
                      </>
                    )}
                  </>
                </React.Fragment>
              );
            })
            : null}
        </div>
      </>
    );
  }
}

export default class View extends Component {
  constructor(props) {
    super(props);
  }

  services = new Services();
  url = new URLSearchParams(window.location.search);
  state = {
    confession: null,
    comment: [],
    report: false
  };
  componentDidMount() {
    fetch(`Confession/GetCurrentConfession?id=${this.url.get("topic")}`, {
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.services.accessToken()}`,
      },
      method: "get",
    })
      .then((r) => r.json())
      .then((response) => {
        const { statusCode } = response;
        if (statusCode === 200) {
          this.setState({ confession: response.value });
        }
      });
  }

  render() {
    return (
      <AuthContext.Consumer>
        {(adminProperties) => {
          const { dark } = adminProperties;
          const { confession } = this.state;

          return (
            <SideNavPost>
              {/* --- Global Report Modal --- */}
              {this.state.report && (
                <ReportConfessionAndComment
                  reportFor={{ type: "confession", id: confession?.id }}
                  closeDiag={() => this.setState({ report: false })}
                />
              )}

              {/* Dynamic theme class applied here */}
              <div className={`view-wrapper ${dark ? 'theme-dark' : 'theme-light'}`}>
                <div className="confession-master-container">
                  {confession ? (
                    <article className="confession-article">

                      {/* --- Post Header --- */}
                      <header className="post-header">
                        <div className="author-block">
                          <div className="main-avatar">
                            <Face6Icon />
                          </div>
                          <div className="author-details">
                            <span className="author-name">Unsigned Participant</span>
                            <div className="post-meta">
                              <time className="meta-time">
                                {this.services.normalizeASPDate(confession.added)}
                              </time>

                              {confession.lastModified !== confession.added && (
                                <span className="edit-badge">
                                  â€¢ Edited {this.services.normalizeASPDate(confession.lastModified)}
                                </span>
                              )}
                            </div>
                          </div>
                        </div>

                        <button
                          className="report-trigger-btn"
                          onClick={() => this.setState({ report: true })}
                          title="Report Post"
                        >
                          <ReportGmailerrorredIcon fontSize="small" />
                        </button>
                      </header>

                      {/* --- Post Content --- */}
                      <div className="post-content">
                        <h1 className="post-topic">{confession.topic}</h1>
                        <div className="post-body">{confession.description}</div>
                      </div>

                      {/* --- Engagement Section --- */}
                      <section className="discussion-area">
                        <div className="discussion-header">
                          <h3>Community Discussion</h3>
                        </div>
                        <Comment deletedConfession={confession.deleted} />
                      </section>

                    </article>
                  ) : (
                    <div className="loading-shimmer">Gathering thoughts...</div>
                  )}
                </div>
              </div>
            </SideNavPost>
          );
        }}
      </AuthContext.Consumer>
    );
  }
}

class ReportConfessionAndComment extends Component {
  constructor(props) {
    super(props);
    this.state = {
      reason: '',
      isSubmitting: false,
      report: false
    };

    this.handleChange = this.handleChange.bind(this);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
  services = new Services();

  handleChange(event) {
    this.setState({ reason: event.target.value });
  }

  handleSubmit(event) {
    event.preventDefault();
    this.setState({ isSubmitting: true });
    const data = new FormData(event.currentTarget);
    const { reportFor } = this.props;
    const { type, id } = reportFor;

    let comId; // comment id
    let confId; // confession id

    if (type === "confession") {
      confId = id;
      comId = null;
    } else if (type === "comments") {
      comId = id;
      confId = null;
    }

    fetch(`Confession/report`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${this.services.accessToken()}`,
      },
      body: JSON.stringify({
        reason: data.get("reason"),
        Comments: comId,
        Confession: confId,
        type
      })
    }).then((r) => r.json()).then((response) => {
      const { statusCode } = response;

      if (statusCode === 200) {
        // let's close this dialuge once everything is done;
        this.props.closeDiag();
      }
    }).catch((err) => {
      alert("Something wen't wrong please try to refresh the site!");
    });
  }

  cancelReport = () => {
    this.props.closeDiag();
  }

  render() {
    const { reason, isSubmitting } = this.state;

    return (
      // The outer overlay: covers screen, darkens background, handles outside clicks
      <div className="modal-overlay" onClick={this.props.onClose}>
        {/* The modal content box: sits in center. stopPropagation prevents closing when clicking inside */}
        <div className="report-modal-container" onClick={e => e.stopPropagation()}>

          <header className="report-header">
            <h2>Report Content</h2>
            <p>Help keep our community safe. Why are you reporting this?</p>
          </header>

          <form onSubmit={this.handleSubmit}>
            <div className="form-group">
              <textarea
                id="reason-input"
                name="reason"
                value={reason}
                onChange={this.handleChange}
                placeholder="e.g. Harassment, hate speech, personal information..."
                required
              />
            </div>

            <div className="report-footer">
              <button
                type="button"
                className="cancel-btn"
                onClick={() => { this.cancelReport() }}
                disabled={isSubmitting}
              >
                Cancel
              </button>
              <button
                type="submit"
                className="submit-btn"
                disabled={!reason.trim() || isSubmitting}
              >
                {isSubmitting ? 'Submitting...' : 'Submit Report'}
              </button>
            </div>
          </form>
        </div>
      </div >
    );
  }
}
